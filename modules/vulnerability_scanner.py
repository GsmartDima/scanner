"""
Vulnerability Assessment Module
Handles CVE matching and vulnerability assessment based on detected services
"""
import asyncio
import httpx
import re
import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
import json

from models import Vulnerability, PortScanResult, Asset, MitreReference
from config import settings, CVE_SEVERITY_SCORES
from modules.security_utils import validate_external_url, is_safe_domain
try:
    from modules.ml_exploit_prediction import MLExploitPredictor, SalesIntelligenceGenerator
    ML_AVAILABLE = True
except ImportError:
    ML_AVAILABLE = False
    logger.warning("ML exploit prediction module not available - some features will be disabled")

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans for vulnerabilities based on detected services and versions"""
    
    def __init__(self):
        self.cve_api_url = settings.cve_api_url
        self.http_timeout = 30
        
        # Cache for CVE lookups to avoid repeated API calls
        self.cve_cache = {}
        self.cache_ttl = timedelta(hours=24)
        
        # MITRE ATT&CK technique mappings for common vulnerabilities
        self.mitre_mappings = {
            'WEB-HTTP-INSECURE': [
                MitreReference(
                    technique_id="T1557",
                    technique_name="Adversary-in-the-Middle",
                    tactic="Credential Access"
                )
            ],
            'WEB-STRICT-TRANSPORT-SECURITY': [
                MitreReference(
                    technique_id="T1557.001",
                    technique_name="LLMNR/NBT-NS Poisoning and SMB Relay",
                    tactic="Credential Access",
                    sub_technique="T1557.001"
                )
            ],
            'WEB-CONTENT-SECURITY-POLICY': [
                MitreReference(
                    technique_id="T1189",
                    technique_name="Drive-by Compromise",
                    tactic="Initial Access"
                )
            ],
            'WEB-X-FRAME-OPTIONS': [
                MitreReference(
                    technique_id="T1189",
                    technique_name="Drive-by Compromise",
                    tactic="Initial Access"
                )
            ],
            'WEB-X-XSS-PROTECTION': [
                MitreReference(
                    technique_id="T1059.007",
                    technique_name="Command and Scripting Interpreter: JavaScript",
                    tactic="Execution",
                    sub_technique="T1059.007"
                )
            ],
            'WEB-MISSING-WAF': [
                MitreReference(
                    technique_id="T1190",
                    technique_name="Exploit Public-Facing Application",
                    tactic="Initial Access"
                ),
                MitreReference(
                    technique_id="T1059.007",
                    technique_name="Command and Scripting Interpreter: JavaScript",
                    tactic="Execution",
                    sub_technique="T1059.007"
                )
            ],
            'ftp': [
                MitreReference(
                    technique_id="T1190",
                    technique_name="Exploit Public-Facing Application",
                    tactic="Initial Access"
                )
            ],
            'telnet': [
                MitreReference(
                    technique_id="T1021.004",
                    technique_name="Remote Services: SSH",
                    tactic="Lateral Movement",
                    sub_technique="T1021.004"
                )
            ],
            'smtp': [
                MitreReference(
                    technique_id="T1566.001",
                    technique_name="Phishing: Spearphishing Attachment",
                    tactic="Initial Access",
                    sub_technique="T1566.001"
                )
            ],
            'snmp': [
                MitreReference(
                    technique_id="T1046",
                    technique_name="Network Service Scanning",
                    tactic="Discovery"
                )
            ]
        }
        
        # Known vulnerable versions (basic patterns)
        self.known_vulnerabilities = {
            'apache': {
                '2.4.49': ['CVE-2021-41773', 'CVE-2021-42013'],
                '2.4.29': ['CVE-2019-0217'],
                '2.2.34': ['CVE-2017-15715']
            },
            'nginx': {
                '1.20.1': ['CVE-2021-23017'],
                '1.18.0': ['CVE-2019-20372']
            },
            'openssh': {
                '7.4': ['CVE-2018-15473'],
                '6.6': ['CVE-2016-0777', 'CVE-2016-0778']
            },
            'mysql': {
                '5.7.29': ['CVE-2020-2922'],
                '8.0.19': ['CVE-2020-2934']
            },
            'postgresql': {
                '12.2': ['CVE-2020-1720'],
                '11.7': ['CVE-2020-1720']
            }
        }
    
    async def assess_vulnerabilities(self, port_results: List[PortScanResult], 
                                   assets: List[Asset], 
                                   web_security_results: List = None) -> List[Vulnerability]:
        """Assess vulnerabilities based on port scan results and assets"""
        logger.info(f"Starting vulnerability assessment for {len(port_results)} port results")
        
        vulnerabilities = []
        
        # Check port-based vulnerabilities
        port_vulns = await self._assess_port_vulnerabilities(port_results)
        vulnerabilities.extend(port_vulns)
        
        # Check web application vulnerabilities
        web_vulns = await self._assess_web_vulnerabilities(assets)
        vulnerabilities.extend(web_vulns)
        
        # Convert web security issues to vulnerabilities
        if web_security_results:
            web_security_vulns = await self._convert_web_security_to_vulnerabilities(web_security_results)
            vulnerabilities.extend(web_security_vulns)
        
        # Remove duplicates
        unique_vulns = self._remove_duplicate_vulnerabilities(vulnerabilities)
        
        logger.info(f"Found {len(unique_vulns)} unique vulnerabilities")
        return unique_vulns
    
    async def _assess_port_vulnerabilities(self, port_results: List[PortScanResult]) -> List[Vulnerability]:
        """Assess vulnerabilities based on open ports and detected services"""
        vulnerabilities = []
        
        for port_result in port_results:
            if port_result.state != 'open':
                continue
            
            # Check for service-specific vulnerabilities
            service_vulns = await self._check_service_vulnerabilities(port_result)
            vulnerabilities.extend(service_vulns)
            
            # Check for version-specific vulnerabilities
            if port_result.version:
                version_vulns = await self._check_version_vulnerabilities(port_result)
                vulnerabilities.extend(version_vulns)
        
        return vulnerabilities
    
    async def _check_service_vulnerabilities(self, port_result: PortScanResult) -> List[Vulnerability]:
        """Check for vulnerabilities based on service type"""
        vulnerabilities = []
        
        # High-risk services with known issues
        risky_services = {
            'ftp': {
                'cves': ['CVE-2020-9053'],
                'severity': 'HIGH',
                'description': 'FTP service may be vulnerable to various attacks'
            },
            'telnet': {
                'cves': ['CVE-2020-10188'],
                'severity': 'CRITICAL',
                'description': 'Telnet transmits data in cleartext'
            },
            'smtp': {
                'cves': ['CVE-2020-7247'],
                'severity': 'MEDIUM',
                'description': 'SMTP service may be vulnerable to relay attacks'
            },
            'snmp': {
                'cves': ['CVE-2020-15862'],
                'severity': 'HIGH',
                'description': 'SNMP service with default community strings'
            }
        }
        
        service = port_result.service.lower() if port_result.service else ''
        
        for risky_service, vuln_info in risky_services.items():
            if risky_service in service:
                for cve_id in vuln_info['cves']:
                    # Get MITRE techniques for this service
                    mitre_techniques = self.mitre_mappings.get(risky_service, [])
                    
                    vuln = Vulnerability(
                        cve_id=cve_id,
                        severity=vuln_info['severity'],
                        cvss_score=CVE_SEVERITY_SCORES.get(vuln_info['severity'], 5.0),
                        description=vuln_info['description'],
                        affected_service=port_result.service,
                        affected_version=port_result.version,
                        port=port_result.port,
                        discovered_at=datetime.now(),
                        mitre_techniques=mitre_techniques,
                        remediation_advice=self._get_remediation_advice(risky_service, cve_id),
                        risk_factors=self._get_risk_factors(risky_service, port_result.port)
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _check_version_vulnerabilities(self, port_result: PortScanResult) -> List[Vulnerability]:
        """Check for vulnerabilities based on specific versions"""
        vulnerabilities = []
        
        if not port_result.service or not port_result.version:
            return vulnerabilities
        
        service_name = port_result.service.lower()
        version_string = port_result.version.lower()
        
        # Check against known vulnerable versions
        if service_name in self.known_vulnerabilities:
            service_vulns = self.known_vulnerabilities[service_name]
            
            for version_pattern, cve_list in service_vulns.items():
                if version_pattern in version_string:
                    for cve_id in cve_list:
                        # Get detailed CVE information
                        cve_details = await self._get_cve_details(cve_id)
                        
                        if cve_details:
                            vuln = Vulnerability(
                                cve_id=cve_id,
                                severity=cve_details.get('severity', 'MEDIUM'),
                                cvss_score=cve_details.get('cvss_score', 5.0),
                                description=cve_details.get('description', f'Vulnerability in {service_name} {version_pattern}'),
                                affected_service=port_result.service,
                                affected_version=port_result.version,
                                port=port_result.port,
                                exploit_available=cve_details.get('exploit_available', False),
                                patch_available=cve_details.get('patch_available', True),
                                discovered_at=datetime.now()
                            )
                            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _assess_web_vulnerabilities(self, assets: List[Asset]) -> List[Vulnerability]:
        """Assess web application vulnerabilities"""
        vulnerabilities = []
        
        for asset in assets:
            if asset.protocol not in ['http', 'https']:
                continue
            
            # Check for common web vulnerabilities
            web_vulns = await self._check_web_application_issues(asset)
            vulnerabilities.extend(web_vulns)
            
            # Check technology-specific vulnerabilities
            tech_vulns = await self._check_technology_vulnerabilities(asset)
            vulnerabilities.extend(tech_vulns)
        
        return vulnerabilities
    
    async def _check_web_application_issues(self, asset: Asset) -> List[Vulnerability]:
        """Check for common web application security issues"""
        vulnerabilities = []
        
        # Check HTTP headers for security issues
        headers = asset.headers
        
        # Missing security headers (only for HTTPS or if HTTP serves sensitive content)
        if asset.protocol == 'https' or self._likely_serves_sensitive_content(asset):
            security_headers = {
                'x-frame-options': {'description': 'Clickjacking protection missing', 'severity': 'LOW', 'score': 3.0},
                'x-content-type-options': {'description': 'MIME type sniffing protection missing', 'severity': 'LOW', 'score': 2.0},
                'x-xss-protection': {'description': 'XSS protection header missing', 'severity': 'LOW', 'score': 3.0},
                'strict-transport-security': {'description': 'HSTS header missing (HTTPS only)', 'severity': 'MEDIUM', 'score': 4.0},
                'content-security-policy': {'description': 'CSP header missing', 'severity': 'LOW', 'score': 3.0}
            }
            
            # Skip HSTS check for HTTP sites
            if asset.protocol == 'http':
                security_headers.pop('strict-transport-security', None)
            
            for header, info in security_headers.items():
                if header not in [h.lower() for h in headers.keys()]:
                    cve_id = f"WEB-{header.upper()}"
                    mitre_techniques = self.mitre_mappings.get(cve_id, [])
                    vuln = Vulnerability(
                        cve_id=cve_id,
                        severity=info['severity'],
                        cvss_score=info['score'],
                        description=info['description'],
                        affected_service='Web Application',
                        port=asset.port,
                        discovered_at=datetime.now(),
                        mitre_techniques=mitre_techniques,
                        remediation_advice=self._get_remediation_advice(cve_id, cve_id),
                        risk_factors=self._get_risk_factors('web', asset.port)
                    )
                    vulnerabilities.append(vuln)
        
                    # Only flag HTTP as a concern if it's serving login/sensitive pages
        if asset.protocol == 'http' and self._likely_serves_sensitive_content(asset):
            mitre_techniques = self.mitre_mappings.get('WEB-HTTP-INSECURE', [])
            vuln = Vulnerability(
                cve_id='WEB-HTTP-INSECURE',
                severity='MEDIUM',
                cvss_score=5.0,
                description='HTTP used for potentially sensitive content (consider HTTPS)',
                affected_service='HTTP',
                port=asset.port,
                discovered_at=datetime.now(),
                mitre_techniques=mitre_techniques,
                remediation_advice='Implement HTTPS for all sensitive pages including login, forms, and user data',
                risk_factors=['Unencrypted data transmission', 'Potential credential exposure', 'Man-in-the-middle attacks']
            )
            vulnerabilities.append(vuln)
        
        # Check for missing WAF protection on web applications
        if asset.protocol in ['http', 'https'] and self._likely_serves_sensitive_content(asset):
            # WAF detection will be handled separately in web security scan
            # This is a placeholder for potential WAF-related vulnerabilities
            pass
        
        return vulnerabilities
    
    async def _convert_web_security_to_vulnerabilities(self, web_security_results: List) -> List[Vulnerability]:
        """Convert web security issues to vulnerabilities"""
        vulnerabilities = []
        
        for web_result in web_security_results:
            # Check for missing WAF protection
            if (hasattr(web_result, 'missing_security_features') and 
                'Web Application Firewall (WAF)' in web_result.missing_security_features):
                
                mitre_techniques = self.mitre_mappings.get('WEB-MISSING-WAF', [])
                vuln = Vulnerability(
                    cve_id='WEB-MISSING-WAF',
                    severity='MEDIUM',
                    cvss_score=4.0,
                    description='Web Application Firewall (WAF) protection not detected',
                    affected_service='Web Application',
                    port=getattr(web_result, 'port', 80),
                    discovered_at=datetime.now(),
                    mitre_techniques=mitre_techniques,
                    remediation_advice='Implement a Web Application Firewall (WAF) to protect against common web application attacks such as XSS, SQL injection, and DDoS attacks. Consider cloud-based WAF solutions like Cloudflare, AWS WAF, or Azure Application Gateway.',
                    risk_factors=[
                        'No protection against common web attacks',
                        'Vulnerable to automated attack tools',
                        'No rate limiting protection',
                        'No malicious traffic filtering'
                    ]
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities

    def _likely_serves_sensitive_content(self, asset: Asset) -> bool:
        """Determine if an asset likely serves sensitive content based on available indicators"""
        # Check subdomain patterns that typically serve sensitive content
        if asset.subdomain:
            sensitive_subdomains = ['admin', 'login', 'portal', 'dashboard', 'panel', 'account', 'user', 'auth']
            subdomain_lower = asset.subdomain.lower()
            if any(sensitive in subdomain_lower for sensitive in sensitive_subdomains):
                return True
        
        # Check technology stack for indicators of dynamic content
        if asset.tech_stack:
            dynamic_techs = ['PHP', 'WordPress', 'Drupal', 'Joomla', 'Django', 'Flask', 'Rails', 'ASP.NET']
            if any(tech in asset.tech_stack for tech in dynamic_techs):
                return True
        
        # Check page title for login/sensitive indicators (if available)
        if asset.title:
            title_lower = asset.title.lower()
            login_indicators = ['login', 'password', 'sign in', 'log in', 'username', 'email', 'admin', 'dashboard']
            if any(indicator in title_lower for indicator in login_indicators):
                return True
        
        # Check headers for indicators of dynamic content or forms
        if asset.headers:
            # Look for content-type indicating dynamic content
            content_type = asset.headers.get('content-type', '').lower()
            if 'application/json' in content_type or 'application/xml' in content_type:
                return True
            
            # Look for server headers indicating dynamic platforms
            server = asset.headers.get('server', '').lower()
            dynamic_servers = ['php', 'django', 'flask', 'rails', 'asp.net', 'tomcat', 'jetty']
            if any(server_tech in server for server_tech in dynamic_servers):
                return True
        
        # Default to False - don't flag simple HTTP sites
        return False
    
    async def _check_technology_vulnerabilities(self, asset: Asset) -> List[Vulnerability]:
        """Check for technology-specific vulnerabilities"""
        vulnerabilities = []
        
        # WordPress vulnerabilities
        if 'WordPress' in asset.tech_stack:
            wp_vulns = await self._check_wordpress_vulnerabilities(asset)
            vulnerabilities.extend(wp_vulns)
        
        # Other CMS vulnerabilities
        cms_vulns = {
            'Drupal': ['CVE-2018-7600', 'CVE-2018-7602'],
            'Joomla': ['CVE-2020-11888', 'CVE-2020-11889']
        }
        
        for tech in asset.tech_stack:
            if tech in cms_vulns:
                for cve_id in cms_vulns[tech]:
                    cve_details = await self._get_cve_details(cve_id)
                    if cve_details:
                        vuln = Vulnerability(
                            cve_id=cve_id,
                            severity=cve_details.get('severity', 'HIGH'),
                            cvss_score=cve_details.get('cvss_score', 7.0),
                            description=cve_details.get('description', f'{tech} vulnerability'),
                            affected_service=tech,
                            port=asset.port,
                            discovered_at=datetime.now()
                        )
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _check_wordpress_vulnerabilities(self, asset: Asset) -> List[Vulnerability]:
        """Check for WordPress-specific vulnerabilities"""
        vulnerabilities = []
        
        # Common WordPress vulnerabilities
        wp_common_vulns = [
            {
                'cve_id': 'WP-XMLRPC',
                'severity': 'MEDIUM',
                'cvss_score': 5.0,
                'description': 'WordPress XML-RPC endpoint enabled'
            },
            {
                'cve_id': 'WP-VERSION-DISCLOSURE',
                'severity': 'LOW',
                'cvss_score': 2.0,
                'description': 'WordPress version disclosure'
            }
        ]
        
        for vuln_data in wp_common_vulns:
            vuln = Vulnerability(
                cve_id=vuln_data['cve_id'],
                severity=vuln_data['severity'],
                cvss_score=vuln_data['cvss_score'],
                description=vuln_data['description'],
                affected_service='WordPress',
                port=asset.port,
                discovered_at=datetime.now()
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _get_cve_details(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a CVE from NVD API with SSRF protection"""
        # Check cache first
        cache_key = f"{cve_id}_{datetime.now().date()}"
        if cache_key in self.cve_cache:
            cached_data = self.cve_cache[cache_key]
            if datetime.now() - cached_data['timestamp'] < self.cache_ttl:
                return cached_data['data']
        
        try:
            url = f"{self.cve_api_url}/cves/{cve_id}"
            
            # SECURITY: Validate URL against SSRF attacks
            try:
                sanitized_url = validate_external_url(url)
                url = sanitized_url
            except ValueError as e:
                logger.warning(f"SSRF protection blocked CVE API request: {url} - {e}")
                return None
            
            async with httpx.AsyncClient(timeout=self.http_timeout) as client:
                response = await client.get(url)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Extract relevant information
                    cve_details = self._parse_cve_data(data)
                    
                    # Cache the result
                    self.cve_cache[cache_key] = {
                        'data': cve_details,
                        'timestamp': datetime.now()
                    }
                    
                    return cve_details
        
        except Exception as e:
            logger.debug(f"Failed to get CVE details for {cve_id}: {str(e)}")
        
        # Return basic info if API call fails
        return {
            'severity': 'MEDIUM',
            'cvss_score': 5.0,
            'description': f'Vulnerability {cve_id}',
            'exploit_available': False,
            'patch_available': True
        }
    
    def _parse_cve_data(self, cve_data: Dict[str, Any]) -> Dict[str, Any]:
        """Parse CVE data from NVD API response"""
        try:
            vulnerabilities = cve_data.get('vulnerabilities', [])
            if not vulnerabilities:
                return {}
            
            cve_item = vulnerabilities[0].get('cve', {})
            
            # Extract description
            descriptions = cve_item.get('descriptions', [])
            description = ''
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # Extract CVSS score and severity
            metrics = cve_item.get('metrics', {})
            cvss_score = 5.0
            severity = 'MEDIUM'
            
            # Try CVSS v3 first, then v2
            if 'cvssMetricV31' in metrics:
                cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 5.0)
                severity = cvss_data.get('baseSeverity', 'MEDIUM')
            elif 'cvssMetricV30' in metrics:
                cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 5.0)
                severity = cvss_data.get('baseSeverity', 'MEDIUM')
            elif 'cvssMetricV2' in metrics:
                cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 5.0)
                # Map CVSS v2 score to severity
                if cvss_score >= 7.0:
                    severity = 'HIGH'
                elif cvss_score >= 4.0:
                    severity = 'MEDIUM'
                else:
                    severity = 'LOW'
            
            return {
                'severity': severity,
                'cvss_score': cvss_score,
                'description': description,
                'exploit_available': False,  # Would need additional lookup
                'patch_available': True      # Assume patch is available
            }
        
        except Exception as e:
            logger.debug(f"Error parsing CVE data: {str(e)}")
            return {}
    
    def _remove_duplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities based on CVE ID and port"""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            key = f"{vuln.cve_id}_{vuln.port}_{vuln.affected_service}"
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def analyze_vulnerability_results(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Analyze vulnerability results for risk assessment"""
        analysis = {
            'total_vulnerabilities': len(vulnerabilities),
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'avg_cvss_score': 0.0,
            'exploitable_vulns': 0,
            'affected_services': set(),
            'top_cves': []
        }
        
        if not vulnerabilities:
            return analysis
        
        total_cvss = 0
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        
        for vuln in vulnerabilities:
            # Count by severity
            severity_counts[vuln.severity] += 1
            total_cvss += vuln.cvss_score
            
            # Track exploitable vulnerabilities
            if vuln.exploit_available:
                analysis['exploitable_vulns'] += 1
            
            # Track affected services
            if vuln.affected_service:
                analysis['affected_services'].add(vuln.affected_service)
        
        # Set counts
        analysis['critical_count'] = severity_counts['CRITICAL']
        analysis['high_count'] = severity_counts['HIGH']
        analysis['medium_count'] = severity_counts['MEDIUM']
        analysis['low_count'] = severity_counts['LOW']
        
        # Calculate average CVSS score
        analysis['avg_cvss_score'] = total_cvss / len(vulnerabilities)
        
        # Convert set to list for JSON serialization
        analysis['affected_services'] = list(analysis['affected_services'])
        
        # Get top CVEs by severity
        sorted_vulns = sorted(vulnerabilities, key=lambda x: x.cvss_score, reverse=True)
        analysis['top_cves'] = [
            {
                'cve_id': vuln.cve_id,
                'severity': vuln.severity,
                'cvss_score': vuln.cvss_score,
                'description': vuln.description
            }
            for vuln in sorted_vulns[:10]  # Top 10
        ]
        
        return analysis
    
    def _get_remediation_advice(self, service_type: str, cve_id: str) -> Optional[str]:
        """Get remediation advice for specific vulnerabilities"""
        remediation_map = {
            'ftp': "Disable FTP service if not required. If needed, use SFTP instead and implement proper access controls.",
            'telnet': "Replace Telnet with SSH for secure remote access. Disable Telnet service immediately.",
            'smtp': "Configure SMTP relay restrictions, implement SPF/DKIM/DMARC records, and use authenticated SMTP.",
            'snmp': "Change default community strings, restrict SNMP access to management networks, use SNMPv3.",
            'WEB-HTTP-INSECURE': "Implement HTTPS redirect, disable HTTP on production systems, use HSTS headers.",
            'WEB-STRICT-TRANSPORT-SECURITY': "Add 'Strict-Transport-Security' header with appropriate max-age value.",
            'WEB-CONTENT-SECURITY-POLICY': "Implement Content Security Policy header to prevent XSS attacks.",
            'WEB-X-FRAME-OPTIONS': "Add 'X-Frame-Options: DENY' or 'SAMEORIGIN' header to prevent clickjacking.",
            'WEB-X-XSS-PROTECTION': "Add 'X-XSS-Protection: 1; mode=block' header for legacy browser protection.",
            'WEB-MISSING-WAF': "Deploy a Web Application Firewall (WAF) to protect against common web attacks. Consider cloud-based solutions like Cloudflare, AWS WAF, or Azure Application Gateway."
        }
        return remediation_map.get(service_type) or remediation_map.get(cve_id)
    
    def _get_risk_factors(self, service_type: str, port: int) -> List[str]:
        """Get risk factors for specific services and ports"""
        risk_factors = []
        
        # High-risk ports
        if port in [21, 23, 1433, 3306, 3389, 5432, 6379]:
            risk_factors.append("High-risk port exposed to network")
        
        # Service-specific risks
        service_risks = {
            'ftp': ["Unencrypted data transmission", "Weak authentication", "Directory traversal potential"],
            'telnet': ["Cleartext password transmission", "No encryption", "Session hijacking risk"],
            'smtp': ["Open relay potential", "Email spoofing", "Information disclosure"],
            'snmp': ["Information disclosure", "Default community strings", "Amplification attacks"],
            'http': ["Unencrypted communication", "Man-in-the-middle attacks"],
            'web': ["Missing security headers", "Client-side attacks", "Information disclosure"],
            'mysql': ["Database exposure", "Privilege escalation", "Data exfiltration"],
            'postgresql': ["Database exposure", "SQL injection potential", "Data breach risk"],
            'rdp': ["Brute force attacks", "Lateral movement", "Remote code execution"]
        }
        
        if service_type and service_type.lower() in service_risks:
            risk_factors.extend(service_risks[service_type.lower()])
        
        return risk_factors 