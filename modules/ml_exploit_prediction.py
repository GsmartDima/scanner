"""
ML-Based Exploit Prediction and Sales Intelligence Module
Uses machine learning to predict vulnerability exploit likelihood and generate sales-actionable insights
"""
import logging
import numpy as np
import networkx as nx
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import StandardScaler
import torch
import torch.nn as nn
import torch.optim as optim
from models import Vulnerability, ScanResult

logger = logging.getLogger(__name__)


@dataclass
class ExploitPrediction:
    """Exploit prediction result with confidence and reasoning"""
    cve_id: str
    exploit_likelihood: float  # 0.0 to 1.0
    confidence_score: float   # 0.0 to 1.0
    risk_factors: List[str]
    exploit_complexity: str   # "LOW", "MEDIUM", "HIGH"
    time_to_exploit: str     # "IMMEDIATE", "DAYS", "WEEKS", "MONTHS"
    mitigation_priority: int  # 1 (highest) to 5 (lowest)
    sales_impact_score: float # 0.0 to 10.0 for sales prioritization


@dataclass
class SalesIntelligence:
    """Sales-specific vulnerability intelligence"""
    prospect_risk_level: str           # "CRITICAL", "HIGH", "MEDIUM", "LOW"
    immediate_concerns: List[str]       # Top 3-5 concerns for immediate outreach
    business_impact_summary: str       # Executive-friendly summary
    recommended_solutions: List[str]   # Specific product/service recommendations
    urgency_score: float              # 0.0 to 10.0 for prioritizing outreach
    estimated_attack_cost: int        # Estimated cost of potential attack in USD
    compliance_risks: List[str]       # Regulatory compliance issues
    competitive_advantages: List[str]  # How to position against competitors


class VulnerabilityGraphAnalyzer:
    """Uses graph analysis to understand vulnerability relationships"""
    
    def __init__(self):
        self.vulnerability_graph = nx.Graph()
        self.cvss_weights = {
            'attack_vector': 0.25,
            'attack_complexity': 0.15,
            'privileges_required': 0.15,
            'user_interaction': 0.1,
            'scope': 0.1,
            'confidentiality': 0.08,
            'integrity': 0.08,
            'availability': 0.09
        }
    
    def build_vulnerability_graph(self, vulnerabilities: List[Vulnerability]) -> nx.Graph:
        """Build a graph representing vulnerability relationships"""
        G = nx.Graph()
        
        for vuln in vulnerabilities:
            # Add vulnerability node with attributes
            G.add_node(vuln.cve_id, 
                      cvss_score=vuln.cvss_score or 0.0,
                      severity=vuln.severity,
                      affected_service=vuln.affected_service,
                      port=vuln.port,
                      exploit_available=vuln.exploit_available)
            
            # Connect vulnerabilities on the same service/port
            for other_vuln in vulnerabilities:
                if (vuln.cve_id != other_vuln.cve_id and 
                    vuln.affected_service == other_vuln.affected_service and
                    vuln.port == other_vuln.port):
                    G.add_edge(vuln.cve_id, other_vuln.cve_id, 
                              relationship='same_service')
        
        self.vulnerability_graph = G
        return G
    
    def calculate_centrality_scores(self) -> Dict[str, float]:
        """Calculate centrality scores for vulnerability prioritization"""
        if not self.vulnerability_graph.nodes():
            return {}
        
        # Calculate different centrality measures
        betweenness = nx.betweenness_centrality(self.vulnerability_graph)
        closeness = nx.closeness_centrality(self.vulnerability_graph)
        degree = nx.degree_centrality(self.vulnerability_graph)
        
        # Combine centrality measures
        combined_scores = {}
        for node in self.vulnerability_graph.nodes():
            combined_scores[node] = (
                0.4 * betweenness.get(node, 0) +
                0.3 * closeness.get(node, 0) +
                0.3 * degree.get(node, 0)
            )
        
        return combined_scores


class ExploitPredictionNN(nn.Module):
    """Neural network for exploit likelihood prediction"""
    
    def __init__(self, input_size: int = 20):
        super(ExploitPredictionNN, self).__init__()
        self.fc1 = nn.Linear(input_size, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, 16)
        self.fc4 = nn.Linear(16, 1)
        self.dropout = nn.Dropout(0.2)
        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()
    
    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.dropout(x)
        x = self.relu(self.fc2(x))
        x = self.dropout(x)
        x = self.relu(self.fc3(x))
        x = self.sigmoid(self.fc4(x))
        return x


class MLExploitPredictor:
    """Machine learning-based exploit prediction system"""
    
    def __init__(self):
        self.graph_analyzer = VulnerabilityGraphAnalyzer()
        self.tfidf_vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
        self.scaler = StandardScaler()
        self.neural_net = ExploitPredictionNN()
        self.is_trained = False
        
        # Known exploit patterns and indicators
        self.high_exploit_indicators = [
            'remote code execution', 'buffer overflow', 'sql injection',
            'cross-site scripting', 'authentication bypass', 'privilege escalation',
            'directory traversal', 'file inclusion', 'command injection',
            'memory corruption', 'use after free', 'heap overflow'
        ]
        
        self.exploit_complexity_keywords = {
            'LOW': ['unauthenticated', 'remote', 'network', 'public'],
            'MEDIUM': ['authenticated', 'local', 'adjacent'],
            'HIGH': ['physical', 'high privileges', 'complex', 'race condition']
        }
        
        # Industry-specific impact multipliers
        self.industry_impact_multipliers = {
            'financial': 2.5,
            'healthcare': 2.3,
            'government': 2.0,
            'education': 1.8,
            'retail': 1.7,
            'manufacturing': 1.5,
            'technology': 1.4,
            'default': 1.0
        }
    
    def extract_vulnerability_features(self, vuln: Vulnerability) -> np.ndarray:
        """Extract feature vector from vulnerability data"""
        features = []
        
        # Basic numeric features
        features.append(vuln.cvss_score or 0.0)
        features.append(1.0 if vuln.exploit_available else 0.0)
        features.append(1.0 if vuln.patch_available else 0.0)
        features.append(vuln.port or 0)
        
        # Severity encoding
        severity_encoding = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}
        features.append(severity_encoding.get(vuln.severity, 0))
        
        # Service type encoding (common ports)
        web_ports = [80, 443, 8080, 8443]
        db_ports = [3306, 5432, 1433, 27017]
        ssh_ports = [22]
        
        features.append(1.0 if vuln.port in web_ports else 0.0)
        features.append(1.0 if vuln.port in db_ports else 0.0)
        features.append(1.0 if vuln.port in ssh_ports else 0.0)
        
        # Description-based features
        description = (vuln.description or '').lower()
        
        # Check for high-risk keywords
        high_risk_count = sum(1 for indicator in self.high_exploit_indicators 
                             if indicator in description)
        features.append(float(high_risk_count))
        
        # Complexity indicators
        complexity_scores = {'LOW': 3, 'MEDIUM': 2, 'HIGH': 1}
        complexity_score = 0
        for complexity, keywords in self.exploit_complexity_keywords.items():
            keyword_matches = sum(1 for keyword in keywords if keyword in description)
            complexity_score += keyword_matches * complexity_scores[complexity]
        features.append(float(complexity_score))
        
        # Age-based features (if CVE year is available)
        cve_year = self._extract_cve_year(vuln.cve_id)
        current_year = datetime.now().year
        age_score = max(0, current_year - cve_year) if cve_year else 5
        features.append(float(age_score))
        
        # MITRE ATT&CK techniques count
        mitre_count = len(vuln.mitre_techniques) if hasattr(vuln, 'mitre_techniques') and vuln.mitre_techniques else 0
        features.append(float(mitre_count))
        
        # Risk factors count
        risk_factors_count = len(vuln.risk_factors) if hasattr(vuln, 'risk_factors') and vuln.risk_factors else 0
        features.append(float(risk_factors_count))
        
        # Pad to fixed size
        while len(features) < 20:
            features.append(0.0)
        
        return np.array(features[:20])
    
    def _extract_cve_year(self, cve_id: str) -> Optional[int]:
        """Extract year from CVE ID"""
        try:
            if cve_id and cve_id.startswith('CVE-'):
                year_str = cve_id.split('-')[1]
                return int(year_str)
        except (IndexError, ValueError):
            pass
        return None
    
    def predict_exploit_likelihood(self, vuln: Vulnerability, 
                                  context_vulns: List[Vulnerability] = None) -> ExploitPrediction:
        """Predict exploit likelihood for a vulnerability"""
        
        # Extract features
        features = self.extract_vulnerability_features(vuln)
        
        # Graph-based analysis if context provided
        centrality_score = 0.0
        if context_vulns:
            self.graph_analyzer.build_vulnerability_graph(context_vulns + [vuln])
            centrality_scores = self.graph_analyzer.calculate_centrality_scores()
            centrality_score = centrality_scores.get(vuln.cve_id, 0.0)
        
        # Base exploit likelihood calculation
        base_likelihood = self._calculate_base_likelihood(vuln)
        
        # Adjust with centrality score
        exploit_likelihood = min(1.0, base_likelihood + (centrality_score * 0.2))
        
        # Determine complexity and time to exploit
        complexity = self._determine_exploit_complexity(vuln)
        time_to_exploit = self._estimate_time_to_exploit(vuln, exploit_likelihood)
        
        # Calculate confidence based on available data
        confidence = self._calculate_confidence(vuln)
        
        # Determine mitigation priority
        priority = self._calculate_mitigation_priority(exploit_likelihood, vuln.cvss_score or 0.0)
        
        # Calculate sales impact score
        sales_impact = self._calculate_sales_impact(vuln, exploit_likelihood)
        
        # Generate risk factors
        risk_factors = self._generate_risk_factors(vuln, exploit_likelihood)
        
        return ExploitPrediction(
            cve_id=vuln.cve_id,
            exploit_likelihood=exploit_likelihood,
            confidence_score=confidence,
            risk_factors=risk_factors,
            exploit_complexity=complexity,
            time_to_exploit=time_to_exploit,
            mitigation_priority=priority,
            sales_impact_score=sales_impact
        )
    
    def _calculate_base_likelihood(self, vuln: Vulnerability) -> float:
        """Calculate base exploit likelihood"""
        likelihood = 0.1  # Base minimum
        
        # CVSS score contribution (40% weight)
        cvss_score = vuln.cvss_score or 0.0
        likelihood += (cvss_score / 10.0) * 0.4
        
        # Exploit availability (30% weight)
        if vuln.exploit_available:
            likelihood += 0.3
        
        # Description analysis (20% weight)
        description = (vuln.description or '').lower()
        exploit_keywords = sum(1 for keyword in self.high_exploit_indicators 
                              if keyword in description)
        likelihood += min(0.2, exploit_keywords * 0.05)
        
        # Severity contribution (10% weight)
        severity_scores = {'CRITICAL': 0.1, 'HIGH': 0.07, 'MEDIUM': 0.04, 'LOW': 0.01}
        likelihood += severity_scores.get(vuln.severity, 0.0)
        
        return min(1.0, likelihood)
    
    def _determine_exploit_complexity(self, vuln: Vulnerability) -> str:
        """Determine exploit complexity level"""
        description = (vuln.description or '').lower()
        
        # Check for complexity indicators
        low_complexity = sum(1 for keyword in self.exploit_complexity_keywords['LOW'] 
                           if keyword in description)
        high_complexity = sum(1 for keyword in self.exploit_complexity_keywords['HIGH'] 
                            if keyword in description)
        
        if high_complexity > low_complexity:
            return "HIGH"
        elif low_complexity > 0:
            return "LOW"
        else:
            return "MEDIUM"
    
    def _estimate_time_to_exploit(self, vuln: Vulnerability, likelihood: float) -> str:
        """Estimate time to exploit"""
        if vuln.exploit_available and likelihood > 0.8:
            return "IMMEDIATE"
        elif likelihood > 0.6:
            return "DAYS"
        elif likelihood > 0.3:
            return "WEEKS"
        else:
            return "MONTHS"
    
    def _calculate_confidence(self, vuln: Vulnerability) -> float:
        """Calculate prediction confidence based on available data"""
        confidence = 0.5  # Base confidence
        
        # More data = higher confidence
        if vuln.cvss_score:
            confidence += 0.2
        if vuln.description:
            confidence += 0.1
        if hasattr(vuln, 'mitre_techniques') and vuln.mitre_techniques:
            confidence += 0.1
        if hasattr(vuln, 'risk_factors') and vuln.risk_factors:
            confidence += 0.1
        
        return min(1.0, confidence)
    
    def _calculate_mitigation_priority(self, likelihood: float, cvss_score: float) -> int:
        """Calculate mitigation priority (1=highest, 5=lowest)"""
        combined_score = (likelihood * 10 + cvss_score) / 2
        
        if combined_score >= 8.5:
            return 1
        elif combined_score >= 7.0:
            return 2
        elif combined_score >= 5.0:
            return 3
        elif combined_score >= 3.0:
            return 4
        else:
            return 5
    
    def _calculate_sales_impact(self, vuln: Vulnerability, likelihood: float) -> float:
        """Calculate sales impact score for prioritization"""
        base_score = likelihood * 5  # Base 0-5 scale
        
        # Severity multiplier
        severity_multipliers = {'CRITICAL': 2.0, 'HIGH': 1.5, 'MEDIUM': 1.2, 'LOW': 1.0}
        base_score *= severity_multipliers.get(vuln.severity, 1.0)
        
        # Exploit availability bonus
        if vuln.exploit_available:
            base_score += 1.0
        
        # Service type multiplier (web services = higher sales impact)
        if vuln.port in [80, 443, 8080, 8443]:
            base_score *= 1.3
        
        return min(10.0, base_score)
    
    def _generate_risk_factors(self, vuln: Vulnerability, likelihood: float) -> List[str]:
        """Generate list of risk factors for the vulnerability"""
        factors = []
        
        if vuln.exploit_available:
            factors.append("Public exploit code available")
        
        if vuln.cvss_score and vuln.cvss_score >= 7.0:
            factors.append("High CVSS score indicates severe impact")
        
        if vuln.port in [80, 443, 8080, 8443]:
            factors.append("Affects web-accessible service")
        
        if vuln.port in [22, 3389]:
            factors.append("Affects remote access service")
        
        if vuln.port in [3306, 5432, 1433, 27017]:
            factors.append("Affects database service")
        
        if not vuln.patch_available:
            factors.append("No patch currently available")
        
        if likelihood > 0.7:
            factors.append("High probability of exploitation")
        
        description = (vuln.description or '').lower()
        if any(keyword in description for keyword in ['remote', 'unauthenticated']):
            factors.append("Can be exploited remotely without authentication")
        
        return factors


class SalesIntelligenceGenerator:
    """Generate sales-specific intelligence from vulnerability data"""
    
    def __init__(self):
        self.ml_predictor = MLExploitPredictor()
        
        # Industry average attack costs (in USD)
        self.attack_cost_estimates = {
            'data_breach': 4_240_000,
            'ransomware': 1_850_000,
            'business_disruption': 1_200_000,
            'reputation_damage': 800_000,
            'regulatory_fines': 2_100_000
        }
        
        # Compliance frameworks
        self.compliance_frameworks = {
            'financial': ['SOX', 'PCI DSS', 'GLBA'],
            'healthcare': ['HIPAA', 'HITECH'],
            'government': ['FISMA', 'NIST'],
            'retail': ['PCI DSS'],
            'general': ['GDPR', 'CCPA', 'ISO 27001']
        }
    
    def generate_sales_intelligence(self, scan_result: ScanResult, 
                                   industry: str = 'general') -> SalesIntelligence:
        """Generate comprehensive sales intelligence from scan results"""
        
        # Get exploit predictions for all vulnerabilities
        predictions = []
        for vuln in scan_result.vulnerabilities:
            prediction = self.ml_predictor.predict_exploit_likelihood(
                vuln, scan_result.vulnerabilities
            )
            predictions.append(prediction)
        
        # Sort by sales impact score
        predictions.sort(key=lambda x: x.sales_impact_score, reverse=True)
        
        # Generate sales intelligence
        risk_level = self._determine_prospect_risk_level(predictions)
        immediate_concerns = self._generate_immediate_concerns(predictions[:5])
        business_impact = self._generate_business_impact_summary(predictions, industry)
        recommendations = self._generate_solution_recommendations(predictions)
        urgency_score = self._calculate_urgency_score(predictions)
        attack_cost = self._estimate_attack_cost(predictions, industry)
        compliance_risks = self._identify_compliance_risks(predictions, industry)
        competitive_advantages = self._generate_competitive_advantages(predictions)
        
        return SalesIntelligence(
            prospect_risk_level=risk_level,
            immediate_concerns=immediate_concerns,
            business_impact_summary=business_impact,
            recommended_solutions=recommendations,
            urgency_score=urgency_score,
            estimated_attack_cost=attack_cost,
            compliance_risks=compliance_risks,
            competitive_advantages=competitive_advantages
        )
    
    def _determine_prospect_risk_level(self, predictions: List[ExploitPrediction]) -> str:
        """Determine overall prospect risk level"""
        if not predictions:
            return "LOW"
        
        critical_count = sum(1 for p in predictions if p.exploit_likelihood > 0.8)
        high_count = sum(1 for p in predictions if p.exploit_likelihood > 0.6)
        
        if critical_count >= 3:
            return "CRITICAL"
        elif critical_count >= 1 or high_count >= 5:
            return "HIGH"
        elif high_count >= 2:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_immediate_concerns(self, top_predictions: List[ExploitPrediction]) -> List[str]:
        """Generate immediate concerns for sales outreach"""
        concerns = []
        
        for pred in top_predictions:
            if pred.exploit_likelihood > 0.7:
                if pred.time_to_exploit == "IMMEDIATE":
                    concerns.append(f"Critical vulnerability {pred.cve_id} can be exploited immediately")
                else:
                    concerns.append(f"High-risk vulnerability {pred.cve_id} ({pred.time_to_exploit.lower()} to exploit)")
            
            if len(concerns) >= 5:
                break
        
        return concerns
    
    def _generate_business_impact_summary(self, predictions: List[ExploitPrediction], 
                                         industry: str) -> str:
        """Generate executive-friendly business impact summary"""
        if not predictions:
            return "Low security risk profile with minimal immediate threats."
        
        high_risk_count = sum(1 for p in predictions if p.exploit_likelihood > 0.6)
        avg_impact_score = sum(p.sales_impact_score for p in predictions) / len(predictions)
        
        industry_multiplier = self.ml_predictor.industry_impact_multipliers.get(industry, 1.0)
        
        if avg_impact_score * industry_multiplier > 7.0:
            return f"Significant security exposure detected with {high_risk_count} high-probability threats. Immediate action required to prevent potential business disruption, data breaches, and regulatory compliance violations."
        elif avg_impact_score * industry_multiplier > 5.0:
            return f"Moderate security risk with {high_risk_count} vulnerabilities requiring attention. Proactive security measures recommended to prevent escalation of threats."
        else:
            return f"Manageable security posture with {len(predictions)} identified vulnerabilities. Regular security monitoring and updates recommended."
    
    def _generate_solution_recommendations(self, predictions: List[ExploitPrediction]) -> List[str]:
        """Generate specific solution recommendations"""
        recommendations = []
        
        # Vulnerability management
        critical_count = sum(1 for p in predictions if p.mitigation_priority <= 2)
        if critical_count > 0:
            recommendations.append("Vulnerability Management Platform for automated scanning and remediation")
        
        # Web application security
        web_vulns = sum(1 for p in predictions if any('web' in rf.lower() for rf in p.risk_factors))
        if web_vulns > 0:
            recommendations.append("Web Application Firewall (WAF) for real-time threat protection")
        
        # Network security
        network_vulns = sum(1 for p in predictions if any('remote' in rf.lower() for rf in p.risk_factors))
        if network_vulns > 0:
            recommendations.append("Next-Generation Firewall (NGFW) and intrusion prevention")
        
        # Monitoring and response
        if len(predictions) > 5:
            recommendations.append("Security Information and Event Management (SIEM) solution")
            recommendations.append("24/7 Security Operations Center (SOC) monitoring")
        
        # Compliance and governance
        high_impact_count = sum(1 for p in predictions if p.sales_impact_score > 6.0)
        if high_impact_count > 0:
            recommendations.append("Governance, Risk, and Compliance (GRC) platform")
        
        return recommendations
    
    def _calculate_urgency_score(self, predictions: List[ExploitPrediction]) -> float:
        """Calculate urgency score for sales prioritization"""
        if not predictions:
            return 1.0
        
        immediate_threats = sum(1 for p in predictions if p.time_to_exploit == "IMMEDIATE")
        high_likelihood = sum(1 for p in predictions if p.exploit_likelihood > 0.7)
        
        urgency = (immediate_threats * 3 + high_likelihood * 2) / max(len(predictions), 1)
        return min(10.0, urgency * 2)
    
    def _estimate_attack_cost(self, predictions: List[ExploitPrediction], 
                             industry: str) -> int:
        """Estimate potential cost of successful attack"""
        if not predictions:
            return 100_000
        
        base_cost = 500_000  # Base attack cost
        
        # Add costs based on vulnerability types and likelihood
        for pred in predictions:
            if pred.exploit_likelihood > 0.7:
                base_cost += 300_000
            elif pred.exploit_likelihood > 0.5:
                base_cost += 150_000
        
        # Industry multiplier
        industry_multiplier = self.ml_predictor.industry_impact_multipliers.get(industry, 1.0)
        
        return int(base_cost * industry_multiplier)
    
    def _identify_compliance_risks(self, predictions: List[ExploitPrediction], 
                                  industry: str) -> List[str]:
        """Identify compliance risks based on vulnerabilities"""
        risks = []
        
        frameworks = self.compliance_frameworks.get(industry, ['GDPR', 'ISO 27001'])
        
        high_risk_count = sum(1 for p in predictions if p.exploit_likelihood > 0.6)
        
        if high_risk_count > 0:
            for framework in frameworks:
                risks.append(f"{framework} compliance violation due to inadequate security controls")
        
        return risks
    
    def _generate_competitive_advantages(self, predictions: List[ExploitPrediction]) -> List[str]:
        """Generate competitive positioning advantages"""
        advantages = []
        
        if predictions:
            advantages.append("Comprehensive vulnerability assessment reveals hidden security gaps")
            
            immediate_count = sum(1 for p in predictions if p.time_to_exploit == "IMMEDIATE")
            if immediate_count > 0:
                advantages.append("Immediate threat detection capabilities surpass basic security scanners")
            
            advantages.append("AI-powered exploit prediction provides proactive security insights")
            advantages.append("Risk prioritization helps focus security investments effectively")
        
        return advantages 